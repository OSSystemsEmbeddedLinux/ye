#! /usr/bin/env python

### TODO

# g <args>
# grep <args>
#    Run 'repo grep <args>' under the current project.

# ll <pkg>
# loglist <pkg>
#      Show the log files for <pkg>

# l <pkg> <task expr>
# log <pkg> <task expr>
#    Show log.do_<task> for <task expr>

# lr <pkg> <task expr>
# logrun <pkg> <task expr>
#    Show run.do_<task> for <task expr>

# emacs fallback: zile, mg, vi


import os
import re
import sys
import glob

YE_PAGER = None
if os.environ.has_key('YE_PAGER'):
    YE_PAGER = os.environ['YE_PAGER']
elif os.environ.has_key('PAGER'):
    YE_PAGER = os.environ['PAGER']
else:
    YE_PAGER = 'nl -ba "%s" | less'

YE_EDITOR = None
if os.environ.has_key('YE_EDITOR'):
    YE_EDITOR = os.environ['YE_EDITOR']
elif os.environ.has_key('EDITOR'):
    YE_EDITOR = os.environ['EDITOR']
else:
    YE_EDITOR = 'emacs -nw' # the true and only sane option
YE_EDITOR += ' "%s"'

BUILDDIR = None
try:
    BUILDDIR = os.environ['BUILDDIR']
except:
    pass

HOME = os.environ['HOME']


def die(msg):
    sys.stderr.write(msg + '\n')
    sys.exit(1)


def colorize(text, pattern):
    return re.sub(pattern,
                  lambda m: '\x1b[31;1m{}\x1b[0m'.format(m.group()), text)


def find_yocto_root():
    def inner_find(dir):
        repo_dir = os.path.join(dir, '.repo')
        if os.path.exists(repo_dir) and os.path.isdir(repo_dir):
            return dir
        elif dir == '/':
            return False
        else:
            return inner_find(os.path.dirname(dir))
    yocto_root = inner_find(os.getcwd())
    return yocto_root or die("ERROR: won't search from /.")


def find_files(basedir, maxdepth=None, pattern='.*'):
    depth = 0
    re_pattern = re.compile(pattern)
    re_skip_pattern = re.compile('~$|^\.#|^#.*#$')
    results = []
    match_whole_path = '/' in pattern
    for root, dirs, files in os.walk(basedir):
        dirs[:] = [d for d in dirs if not d[0] == '.']
        depth += 1
        if maxdepth and depth > maxdepth:
            return results
        all_files = None
        if match_whole_path:
            all_files = [ os.path.join(root, f) for f in dirs + files ]
        else:
            all_files = dirs + files
        for file in all_files:
            if  not re_skip_pattern.match(file) and re_pattern.match(file):
                results.append(os.path.join(root, file))
    return results


def parse_choice(choice, valid_shortcuts):
    result = None
    try:
        choice_num = int(choice)
        result = (choice_num, None)
    except:
        pass
    if result:
        return result
    shortcut = choice[-1:]
    choice = choice[:-1]
    result = (None, None)
    try:
        choice_num = int(choice)
        if not shortcut or shortcut in valid_shortcuts:
            result = (choice_num, shortcut)
    except:
        pass
    return result


def prompt_file(options, colorizer=lambda x: x, valid_shortcuts=[]):
    maxopts = len(options) - 1

    def inner_prompt():
        for i, text in enumerate(options):
            print '[%d] %s [%d]' % (i, colorizer(text), i)
        print 'Option (ENTER to cancel):',
        return raw_input()

    while True:
        choice = inner_prompt()
        if choice == '': # user cancelled
            sys.exit(0)
        choice, shortcut = parse_choice(choice, valid_shortcuts)
        if choice is not None and choice <= maxopts:
            return (choice, shortcut)

def prompt_action(options):
    def inner_prompt():
        for short, text in options:
            print '[%s] %s' % (short, text)
        print 'Option (ENTER to cancel):',
        return raw_input()

    short_options = [ o[0] for o in options ]
    while True:
        choice = inner_prompt()
        if choice == '': # user cancelled
            sys.exit(0)
        try:
            index = short_options.index(choice)
            return index
        except:
            pass

def shorten_path(path):
    home_pos = path.find(HOME)
    if home_pos == 0:
        homeless_path = path[len(HOME):]
        if homeless_path.startswith('/'):
            return '~' + homeless_path
        else:
            return '~/' + homeless_path
    else:
        return path

def find(pattern, basedir, exact, actions, files_only=True):
    ''' actions = [('label', 'shortcut', proc) ...] '''
    results = []
    shortcut = None
    orig_pattern = pattern
    if not exact:
        pattern = '.*%s.*' % pattern
    for file in find_files(basedir, pattern=pattern):
        if not os.path.isdir(file):
            results.append(file)
    if results:
        valid_shortcuts = [ a[1] for a in actions ]
        if len(results) > 1:
            choice, shortcut = prompt_file(results,
                                           lambda file: colorize(shorten_path(file),
                                                                 orig_pattern),
                                           valid_shortcuts)
            file = results[choice]
        else:
            file = results[0]
            print colorize(shorten_path(file), orig_pattern)
        if shortcut:
            for action in actions:
                if action[1] == shortcut:
                    action[2](file)
        else:
            action = prompt_action([ (a[1], a[0]) for a in actions ])
            actions[action][2](file)
        print file

def check_builddir():
    if not BUILDDIR:
        die("ERROR: Could not determine the Yocto Project's build directory.")


def find_workdir(pattern, exact):
    check_builddir()
    results = []
    orig_pattern = pattern
    if not exact:
        pattern = '.*%s.*' % pattern
    re_pattern = re.compile(pattern)
    paths = glob.glob(os.path.join(BUILDDIR, 'tmp', 'work', '*', '*'))
    for path in paths:
        if os.path.isdir(path):
            basedir = os.path.dirname(path)
            dir = os.path.basename(path)
            if re_pattern.match(dir):
                results.append(os.path.join(basedir, dir))
    for result in results:
        print colorize(result, orig_pattern)


def pkg_view(file):
    ext = os.path.splitext(file)[1]
    if ext in ['.ipk', '.deb']:
        os.system("ar p %s data.tar.gz | tar tvzf -" % file)
    elif ext == '.rpm':
        os.system("rpm -qlp %s" % file)
    else:
        die("ERROR: unsupported package file extension: %s" % ext)


def pkg_info(file):
    ext = os.path.splitext(file)[1]
    if ext in ['.ipk', '.deb']:
        os.system("ar p %s control.tar.gz | tar xzf - ./control -O" % file)
    elif ext == '.rpm':
        os.system("rpm -qip %s" % file)
    else:
        die("ERROR: unsupported package file extension: %s" % ext)


view_action = ('View', 'v', lambda file: os.system(YE_PAGER % file))

edit_action = ('Edit', 'e', lambda file: os.system(YE_EDITOR % file))

pkg_view_action = ('View', 'v', pkg_view)

pkg_info_action = ('Info', 'i', pkg_info)


def usage(exit_code=None, cmd=None):
    printer = None
    if exit_code is not None and exit_code != 0:
        printer = sys.stderr.write
    else:
        printer = sys.stdout.write
    printer('''Usage: %s <command> [ <options> ]

f [-e] <regex>
find [-e] <regex>
    Locate paths that match the given expression <regex>.  <regex> is
    case insensitive and implicitly surrounded by '.*'.  -e disables
    the implicit use of '.*' around the given <regex>.  Note that,
    unless <regex> contains /, matching is attempted on filenames only
    (not on dirnames).  If <regex> contains /, matching is attempted
    on the full path.

sf [-e] <regex>
sysroot-find [-e] <regex>
    Locate paths that match the given expression <regex>.  <regex> is
    case insensitive and implicitly surrounded by '.*'.  -e disables
    the implicit use of '.*' around the given <regex>.   Note that,
    unless <regex> contains /, matching is attempted on filenames only
    (not on dirnames).  If <regex> contains /, matching is attempted
    on the full path.

pf [-e] <regex>
pkg-find [-e] <regex>
    Like 'find', but for packages.

wd [-e] <regex>
workdir [-e] <regex>
    Locate the Yocto's workdir for <regex>.  <regex> is implicitly
    surrounded by '.*', unless -e is provided.

''' % os.path.basename(sys.argv[0]))
    if exit_code is not None:
        sys.exit(exit_code)


def main(args):
    if not args:
        usage(1)
    if '-h' in args or '-help' in args or '--help' in args:
        usage(0)
    cmd = args[0]

    if cmd in ['f', 'find', 'sf', 'sysroot-find', 'wd', 'workdir', 'pf', 'pkg-find']:
        cmd_args = args[1:]
        exact = False
        if '-e' in cmd_args:
            exact = True
            cmd_args.remove('-e')
        pattern = cmd_args[0]
        if cmd_args:
            if cmd in ['f', 'find']:
                find(pattern,
                     os.path.join(find_yocto_root(), 'sources'),
                     exact,
                     [view_action, edit_action])
            elif cmd in ['sf', 'sysroot-find']:
                check_builddir()
                sysroots_dir = os.path.join(BUILDDIR, 'tmp', 'sysroots')
                if os.path.isdir(sysroots_dir):
                    find(pattern, sysroots_dir, exact, [view_action, edit_action])
            elif cmd in ['wd', 'workdir']:
                check_builddir()
                if os.path.isdir(os.path.join(BUILDDIR, 'tmp', 'work')):
                    find_workdir(pattern, exact)
            elif cmd in ['pf', 'pkg-find']:
                check_builddir()
                deploy_dir = os.path.join(BUILDDIR, 'tmp', 'deploy')
                pkg_dirs = [ os.path.join(deploy_dir, fmt) for fmt in ['deb', 'ipk', 'rpm'] ]
                pkg_dirs = filter(os.path.isdir, pkg_dirs)
                pkg_dir = None
                if not pkg_dirs:
                    sys.exit(0)
                if len(pkg_dirs) > 1:
                    fmts = [ os.path.basename(dir) for dir in pkg_dirs ]
                    choice = prompt_action( [ (fmt[0], fmt) for fmt in fmts ])
                    pkg_dir = pkg_dirs[choice]
                else:
                    pkg_dir = pkg_dirs[0]
                find(pattern, pkg_dir, exact, [pkg_view_action, pkg_info_action])
        else: usage(1)
    else:
        usage(1)


main(sys.argv[1:])
