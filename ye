#! /usr/bin/env python

## ye: Yocto Explorer
##
## Copyright (C) 2014 O.S. Systems Software LTDA
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU Affero General Public License as
## published by the Free Software Foundation, either version 3 of the
## License, or (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU Affero General Public License for more details.
##
## You should have received a copy of the GNU Affero General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

### TODO
# Implement exclusion pattern for grep (option should not clash with git grep's)

from __future__ import print_function

import os
import re
import sys
import time
import glob
import urllib
import locale
import subprocess

# lxml is required for parsing the documentation XML files
is_lxml_available = True
try:
    from lxml import etree
except:
    is_lxml_available = False

encoding = locale.getdefaultlocale()[1]
if not encoding:
    sys.stderr.write('WARNING: could not determine locale. Forcing UTF-8.\n')
    encoding = 'UTF-8'

def die(msg):
    sys.stderr.write(msg + '\n')
    sys.exit(1)

def is_program_available(program):
    progpaths = os.environ['PATH'].split(':')
    for dir in progpaths:
        progpath = os.path.join(dir, program)
        if os.path.isfile(progpath) and os.access(progpath, os.X_OK):
            return True
    return False

YE_DIR = os.path.join(os.environ['HOME'], '.ye')

EDITOR_ALTERNATIVES = [('emacs', '-nw'), 'mg', 'zile', 'qemacs', 'nano', 'vim', 'vi']

def find_editor():
    for option in EDITOR_ALTERNATIVES:
        editor = None
        args = None
        if isinstance(option, tuple):
            editor = option[0]
            args = option[1]
        else:
            editor = option
        if is_program_available(editor):
            return '%s %s' % (editor, args)
    die('Could not find an editor.  Please, set the YE_EDITOR environment variable.')

YE_PAGER = None
if 'YE_PAGER' in os.environ:
    YE_PAGER = os.environ['YE_PAGER']
elif 'PAGER' in os.environ:
    YE_PAGER = os.environ['PAGER'] + ' %s'
else:
    YE_PAGER = 'less -N "%s"'

YE_EDITOR = None
if 'YE_EDITOR' in os.environ:
    YE_EDITOR = os.environ['YE_EDITOR']
elif 'EDITOR' in os.environ:
    YE_EDITOR = os.environ['EDITOR']
else:
    YE_EDITOR = find_editor()
YE_EDITOR += ' "%s"'

BUILDDIR = None
try:
    BUILDDIR = os.environ['BUILDDIR']
except:
    pass

HOME = os.environ['HOME']

# `raw_input' has been replaced by `input' in Python 3
try:
    input = raw_input
except NameError:
    pass

def colorize(text, pattern):
    if sys.stdout.isatty():
        return re.sub(pattern,
                      lambda m: '\x1b[31;1m{}\x1b[0m'.format(m.group()), text)
    else:
        return text

def paginate(text):
    p = subprocess.Popen(['less', '-FR'], stdin=subprocess.PIPE, close_fds=True)
    p.communicate(text)

def download_file(uri, output_file):
    dir = os.path.dirname(output_file)
    if dir and not os.path.exists(dir):
        os.makedirs(dir)
    try:
        uri_fd = urllib.urlopen(uri)
    except:
        die('Could not download %s.  Aborting' % uri)
    with open(output_file, 'w') as output_fd:
        output_fd.write(uri_fd.read())

def find_yocto_root():
    def inner_find(dir):
        repo_dir = os.path.join(dir, '.repo')
        if os.path.exists(repo_dir) and os.path.isdir(repo_dir):
            return dir
        elif dir == '/':
            return False
        else:
            return inner_find(os.path.dirname(dir))
    yocto_root = inner_find(os.getcwd())
    return yocto_root or die("ERROR: won't search from /.")


def find_files(basedir, maxdepth=None, pattern='.*'):
    depth = 0
    re_pattern = re.compile(pattern)
    re_skip_pattern = re.compile('.*~$|^\.#|^#.*#$|.*\.pyc$')
    results = []
    match_whole_path = '/' in pattern
    for root, dirs, files in os.walk(basedir):
        dirs[:] = [d for d in dirs if not d[0] == '.']
        depth += 1
        if maxdepth and depth > maxdepth:
            return results
        all_files = None
        if match_whole_path:
            all_files = [ os.path.join(root, f) for f in dirs + files ]
        else:
            all_files = dirs + files
        for file in all_files:
            if not re_skip_pattern.match(file) and re_pattern.match(file):
                results.append(os.path.join(root, file))
    return results


def parse_choice(choice, valid_shortcuts):
    result = None
    try:
        choice_num = int(choice)
        result = (choice_num, None)
    except:
        pass
    if result:
        return result
    shortcut = choice[-1:]
    choice = choice[:-1]
    result = (None, None)
    try:
        choice_num = int(choice)
        if not shortcut or shortcut in valid_shortcuts:
            result = (choice_num, shortcut)
    except:
        pass
    return result


def prompt(options, option_formatter=lambda x: x, valid_shortcuts=[]):
    maxopts = len(options) - 1

    def inner_prompt():
        text_options = ''
        for i, text in enumerate(options):
            text_options += '[%d] %s [%d]\n' % (i, option_formatter(text), i)
        paginate(text_options)
        print('Option (ENTER to cancel): ', end='')
        return input()

    while True:
        choice = inner_prompt()
        if choice == '': # user cancelled
            sys.exit(0)
        choice, shortcut = parse_choice(choice, valid_shortcuts)
        if choice is not None and choice <= maxopts:
            return (choice, shortcut)

def prompt_action(options):
    def inner_prompt():
        for short, text in options:
            print('[%s] %s' % (short, text))
        print('Option (ENTER to cancel): ', end='')
        return input()

    short_options = [ o[0] for o in options ]
    while True:
        choice = inner_prompt()
        if choice == '': # user cancelled
            sys.exit(0)
        try:
            index = short_options.index(choice)
            return index
        except:
            pass

def shorten_path(path):
    home_pos = path.find(HOME)
    if home_pos == 0:
        homeless_path = path[len(HOME):]
        if homeless_path.startswith('/'):
            return '~' + homeless_path
        else:
            return '~/' + homeless_path
    else:
        return path

def find(pattern, basedir, exact, actions):
    ''' actions = [('label', 'shortcut', proc) ...] '''
    results = []
    shortcut = None
    orig_pattern = pattern
    if not exact:
        pattern = '.*%s.*' % pattern
    for file in find_files(basedir, pattern=pattern):
        if not os.path.isdir(file):
            results.append(file)
    if sys.stdout.isatty():
        if results:
            valid_shortcuts = [ a[1] for a in actions ]
            if len(results) > 1:
                choice, shortcut = prompt(results,
                                          lambda file: colorize(shorten_path(file),
                                                                orig_pattern),
                                          valid_shortcuts)
                file = results[choice]
            else:
                file = results[0]
                print(colorize(shorten_path(file), orig_pattern))
            if len(actions) == 1:
                actions[0][2](file)
                return file
            if shortcut:
                for action in actions:
                    if action[1] == shortcut:
                        action[2](file)
            else:
                action = prompt_action([ (a[1], a[0]) for a in actions ])
                actions[action][2](file)
            return file
    else:
        if len(results) == 1 and len(actions) == 1:
            actions[0][2](results[0])
        else:
            return results

def check_builddir():
    if not BUILDDIR:
        die("ERROR: Could not determine the Yocto Project's build directory.")


def find_workdir(pattern, exact):
    check_builddir()
    results = []
    orig_pattern = pattern
    if not exact:
        pattern = '.*%s.*' % pattern
    re_pattern = re.compile(pattern)
    paths = glob.glob(os.path.join(BUILDDIR, 'tmp', 'work', '*', '*'))
    for path in paths:
        if os.path.isdir(path):
            basedir = os.path.dirname(path)
            dir = os.path.basename(path)
            if re_pattern.match(dir):
                results.append(os.path.join(basedir, dir))
    return results


def show_workdir(pattern, exact, plumbing_mode=False):
    results = find_workdir(pattern, exact)
    if plumbing_mode:
        len_results = len(results)
        if len_results > 1:
            choice, _ = prompt(results)
            if choice:
                write_plumbing_selection('wd', results[choice])
        elif len_results == 1:
            write_plumbing_selection('wd', results[0])
        else:
            write_plumbing_selection('wd', None)
    else:
        for result in results:
            print(colorize(result, pattern))


def print_matches(matches, plumbing_cmd=None):
    if matches:
        dest = None
        if plumbing_cmd:
            dest = open(os.path.join(YE_DIR, 'plumbing', plumbing_cmd), 'w')
        else:
            dest = sys.stdout
        if matches.__class__.__name__ == 'list':
            for match in matches:
                dest.write(match.encode(encoding) + '\n')
        else:
            # a string
            dest.write(matches.encode(encoding) + '\n')
        if plumbing_cmd:
            dest.close()


def pkg_view(file):
    ext = os.path.splitext(file)[1]
    if ext in ['.ipk', '.deb']:
        os.system("ar p %s data.tar.gz | tar tvzf -" % file)
    elif ext == '.rpm':
        os.system("rpm -qlvp %s" % file)
    else:
        die("ERROR: unsupported package file extension: %s" % ext)


def pkg_info(file):
    ext = os.path.splitext(file)[1]
    if ext in ['.ipk', '.deb']:
        os.system("ar p %s control.tar.gz | tar xzf - ./control -O" % file)
    elif ext == '.rpm':
        os.system("rpm -qip %s" % file)
    else:
        die("ERROR: unsupported package file extension: %s" % ext)


def pkg_scripts(file):
    ext = os.path.splitext(file)[1]
    if ext in ['.ipk', '.deb']:
        os.system("ar p %s control.tar.gz | tar tzf -" % file)
    else:
        die("ERROR: unsupported package file extension: %s" % ext)


def pkg_extract(pkg_file, file, from_control):
    out_dir, ext = os.path.splitext(pkg_file)
    out_dir = os.path.basename(out_dir)
    if os.path.exists(out_dir):
        die("%s already exists.  Won't clobber.  Aborting." % out_dir)
    os.makedirs(out_dir)
    if ext in ['.ipk', '.deb']:
        tarball = 'data.tar.gz'
        if from_control:
            tarball = 'control.tar.gz'
        status = os.system("ar p %s %s | tar xzf - %s -C %s" % (pkg_file, tarball, file, out_dir))
        if not status:
            print('Extracted to %s' % out_dir)
    elif ext == '.rpm':
        if is_program_available('rpm2cpio'):
            os.chdir(out_dir)
            status = os.system("rpm2cpio %s | cpio -id %s" % (pkg_file, file))
            if not status:
                print('Extracted to %s' % out_dir)
        else:
            die('ERROR: This operation requires the "rpm2cpio" program to be installed.')
    else:
        die("ERROR: unsupported package file extension: %s" % ext)


def human_readable_gcc_calls(file):
    formatter = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                             'format-gcc-calls.py')
    os.system('python %s "%s" | less' % (formatter, file))

human_readable_gcc_calls_action = ('View', 'v', human_readable_gcc_calls)

view_action = ('View', 'v', lambda file: os.system(YE_PAGER % file))

edit_action = ('Edit', 'e', lambda file: os.system(YE_EDITOR % file))

pkg_view_action = ('View', 'v', pkg_view)

pkg_info_action = ('Info', 'i', pkg_info)

pkg_scripts_action = ('Scripts', 's', pkg_scripts)

def pkg_extract_action(file, from_control):
    return ('Extract', 'x', lambda pkg: pkg_extract(pkg, file, from_control))


def list_temp_files(file_type, recipe_pattern, log_pattern, exact, raw):
    wds = find_workdir(recipe_pattern, exact)
    if not wds:
        sys.exit(1)
    if len(wds) > 1:
        choice, _ = prompt(wds, os.path.basename)
        wd = wds[choice]
    else:
        wd = wds[0]
    if not os.path.isdir(wd):
        sys.exit(1)
    if file_type == 'log':
        print('=== Showing logs for %s' % os.path.basename(wd))
    else:
        print('=== Showing run scripts for %s' % os.path.basename(wd))
    version_dirs = glob.glob(os.path.join(wd, '*'))
    if len(version_dirs) > 1:
        choice, _ = prompt(version_dirs, os.path.basename)
        version_dir = version_dirs[choice]
    else:
        version_dir = version_dirs[0]
    log_dir = os.path.join(version_dir, 'temp')
    all_files = find_files(log_dir,
                           pattern='%s\..*%s.*' % (file_type, log_pattern))
    logs = [ f for f in all_files if os.path.islink(f) ]
    log = None
    if logs:
        if len(logs) > 1:
            choice, _ = prompt(logs, os.path.basename)
            log = logs[choice]
        else:
            log = logs[0]
        print('=== %s' % log)
        if raw:
            view_action[2](log)
        else:
            human_readable_gcc_calls_action[2](log)
        print(log_dir)


def list_logs(recipe_pattern, log_pattern, exact, raw):
    list_temp_files('log', recipe_pattern, log_pattern, exact, raw)


def list_run_scripts(recipe_pattern, log_pattern, exact):
    list_temp_files('run', recipe_pattern, log_pattern, exact, True)


def grep(args, actions, dir=None):
    if dir:
        p = subprocess.Popen(['grep', '-r'] + args + [dir], stdout=subprocess.PIPE)
    else:
        p = subprocess.Popen(['repo', 'grep'] + args, stdout=subprocess.PIPE)
    regex_pattern = [ arg for arg in args if not arg.startswith('-') ]
    if not regex_pattern:
        die('Could not determine the pattern for grep.')
    if len(regex_pattern) > 1:
        die('Multiple patterns for grep is not supported.')
    regex_pattern = regex_pattern[0]
    output = p.communicate()[0]
    results = output.decode(encoding).split('\n')[:-1] # the last line is always empty
    if sys.stdout.isatty():
        shortcut = None
        if len(results) == 0:
            return None
        elif len(results) > 1:
            choice, shortcut = prompt(results,
                                      option_formatter=lambda o: colorize(o, regex_pattern),
                                      valid_shortcuts=['v', 'e'])
            match = results[choice]
        else:
            match = results[0]
        actions = None
        if shortcut == 'v':
            actions = [view_action]
        elif shortcut == 'e':
            actions = [edit_action]
        else:
            actions = [view_action, edit_action]
        file = match.split(':')[0] # let's hope filenames don't contain ':'
        return find(file,
                    os.path.join(find_yocto_root(), 'sources'),
                    False,
                    actions)
    else:
        return results

def buildhistory(revisions, raw_diff):
    bhdir = os.path.join(BUILDDIR, 'buildhistory')
    if not os.path.isdir(bhdir):
        die('Could not find the buildhistory directory at %s.' % bhdir)
    rev_window = 'HEAD~%d..HEAD' % revisions
    if raw_diff:
        os.system('cd %s && git diff %s' % (bhdir, rev_window))
    else:
        os.system('buildhistory-diff -p %s %s' % (bhdir, rev_window))

def doc(pattern, exact):
    if not is_lxml_available:
        die('You need the lxml Python module for documentation.')

    def remove_duplicate_spaces(text):
        return re.sub(' +', ' ', text)

    def refill_text(text):
        lines = [ line for line in text.split('\n') ]
        return(remove_duplicate_spaces(' '.join(lines)))

    def parse_itemized_list(l):
        text = []
        for item in l.findall('listitem'):
            text.append(parse_paragraph(item))
        return '\n' + '\n'.join(text) + '\n'

    def parse_children(elt, sep=''):
        if elt.text:
            return elt.text
        else:
            children = elt.getchildren()
            if elt.tag in ['link', 'ulink'] and not children:
                return elt.get('url')
            else:
                return sep.join(map(parse_paragraph, children))

    def parse_paragraph(p):
        text = []
        if p.text:
            text.append(refill_text(p.text))
        for elt in p:
            if elt.tag == 'filename':
                text.append('`%s`' % parse_children(elt))
            elif elt.tag == 'listitem':
                text.append('\n\n* %s' % parse_children(elt, sep='\n'))
            elif elt.tag == 'itemizedlist':
                parse_itemized_list(elt)
            elif elt.tag == 'literallayout':
                text.append('\n' + elt.text + '\n')
            elif elt.tag in ['link', 'ulink']:
                text.append(parse_children(elt))
            else:
                parse_paragraph(elt)
            if elt.tail:
                text.append(refill_text(elt.tail))
        if text: # FIXME: this is a hack, should be fixed
            return ''.join([text[0].lstrip()] + text[1:])
        else:
            return ''

    def show_doc(var, doc):
        print('\n=== ' + var)
        print(doc)

    doc_data_dir = os.path.join(YE_DIR, 'doc-data')
    ref_variables_xml = os.path.join(doc_data_dir, 'ref-manual', 'ref-variables.xml')

    # Check if we need to update documentation data
    update_window = 7 * 24 * 3600 # 7 days
    # We use documentation from master
    doc_base_uri = 'https://git.yoctoproject.org/cgit/cgit.cgi/yocto-docs/plain/documentation'
    if (not os.path.exists(ref_variables_xml) or
        os.stat(ref_variables_xml).st_mtime < time.time() - update_window):
        print('Updating documentation data...')
        download_file('%s/poky.ent' % doc_base_uri,
                      os.path.join(doc_data_dir, 'poky.ent'))
        download_file('%s/ref-manual/ref-variables.xml' % doc_base_uri,
                      ref_variables_xml)

    tree = etree.parse(ref_variables_xml)
    glossentries = tree.findall('//glossentry')
    docs = {}

    orig_pattern = pattern
    if not exact:
        pattern = '.*%s.*' % pattern

    for e in glossentries:
        glossterm = e.find('glossterm').text
        if re.compile(pattern).match(glossterm):
            glossdef = e.find('glossdef')
            paragraphs = glossdef.findall('para')
            text = []
            for p in paragraphs:
                text.append(parse_paragraph(p))
            docs[glossterm] = '\n\n'.join(text)
    if docs:
        options = docs.keys()
        if len(options) == 1:
            show_doc(options[0], docs[options[0]])
        elif sys.stdout.isatty():
            choice, _ = prompt(options,
                               lambda var: colorize(shorten_path(var),
                                                    orig_pattern))
            show_doc(options[choice], docs[options[choice]])
        else:
            for o in options:
                print(o)
    else:
        die('No documentation entry for "%s".' % orig_pattern)


def write_plumbing_selection(cmd, val):
    plumbing_selection_dir = os.path.join(YE_DIR, 'plumbing')
    cmd_file = os.path.join(plumbing_selection_dir, cmd)
    if val:
        if not os.path.isdir(plumbing_selection_dir):
            os.makedirs(plumbing_selection_dir)
        fd = open(cmd_file, 'w')
        if isinstance(val, dict):
            for var, value in val.items():
                fd.write('%s=%s\n' % (var, value))
        else:
            print(val)
            fd.write(val + '\n')
        fd.close()
    else:
        if os.path.exists(cmd_file):
            os.remove(cmd_file)


def handle_plumbing(args):
    '''Plumbing is a hack to make the `cd' command possible.  The ye-cd
    script must be evaluated on the user environment to define a ye
    shell function.  This function will check if the command (first
    argument) is `cd' and will handle its arguments accordingly.  If
    the command is not `cd' it will dispatch the command to ye.  In
    case the command is `cd', the ye shell function may need some
    information from ye -- that's why the "plumbing" mode exists.  In
    the plumbing mode, ye will receive a command from the ye shell
    function (plumbing <cdm> [<args>]) and will write the results to
    YE_DIR/plumbing/<cmd>, so that the ye shell function can use them
    upon ye's termination.
    '''
    if args:
        cmd = args[0]
        cmd_args = args[1:]
        exact = False
        if '-e' in cmd_args:
            exact = True
            cmd_args.remove('-e')
        if cmd == 'wd':
            if cmd_args:
                if os.path.isdir(os.path.join(BUILDDIR, 'tmp', 'work')):
                    show_workdir(cmd_args[0], exact, True)
            else:
                die('plumbing wd: missing argument.')
        elif cmd == 'x':
            if cmd_args:
                expand_mod = __import__('bb-expand-vars')
                os.chdir(BUILDDIR)
                val = expand_mod.show_var_expansions('core-image-minimal',
                                                     cmd_args,
                                                     True)
                if val:
                    write_plumbing_selection('x', val)
            else:
                die('plumbing x: missing argument.')
        elif cmd == 'find':
            print_matches(find(cmd_args[0],
                               os.path.join(find_yocto_root(), 'sources'),
                               exact,
                               [('Print', 'p', lambda file: print(file))]),
                          plumbing_cmd=cmd)
        else:
            die('plumbing: invalid command: %s' % cmd)
    else:
        die('plumbing requires an argument.')


def usage(exit_code=None, cmd=None):
    printer = None
    if exit_code is not None and exit_code != 0:
        printer = sys.stderr.write
    else:
        printer = sys.stdout.write
    printer('''Usage: %s <command> [ <options> ]

f [-e] <regex>
find [-e] <regex>
    Locate paths (in the "sources" directory) that match the given
    expression <regex>.  <regex> is case insensitive and implicitly
    surrounded by '.*'.  -e disables the implicit use of '.*' around
    the given <regex>.  Note that, unless <regex> contains /, matching
    is attempted on filenames only (not on dirnames).  If <regex>
    contains /, matching is attempted on the full path.

v [-e] <regex>
view [-e] <regex>
    Shortcut to find & view.  If multiple files are found, a prompt for
    files will be displayed (but not for actions).

e [-e] <regex>
edit [-e] <regex>
    Shortcut to find & edit.  If multiple files are found, a prompt for
    files will be displayed (but not for actions).

sf [-e] <regex>
sysroot-find [-e] <regex>
    Locate paths (in the "sysroots" directory) that match the given
    expression <regex>.  <regex> is case insensitive and implicitly
    surrounded by '.*'.  -e disables the implicit use of '.*' around
    the given <regex>.  Note that, unless <regex> contains /, matching
    is attempted on filenames only (not on dirnames).  If <regex>
    contains /, matching is attempted on the full path.

pf [-e] <regex>
pkg-find [-e] <regex>
    Like 'find', but for packages.

pv [-e] <regex>
pkg-view [-e] <regex>
    Shortcut to pkg-find & view.  If multiple packages are found, a
    prompt for packages will be displayed (but not for actions).

pi [-e] <regex>
pkg-info [-e] <regex>
    Shortcut to pkg-find & info.  If multiple packages are found, a
    prompt for packages will be displayed (but not for actions).

ps [-e] <regex>
pkg-scripts [-e] <regex>
    List scripts for package that matches <regex>.  In case of multiple
    matches, ye will prompt for a specific package. <regex> is case
    insensitive and implicitly surrounded by '.*'.  -e disables the
    implicit use of '.*' around the given <regex>.

px [-e] [-c] <regex> [<file>]
pkg-extract [-e] [-c] <regex> [<file>]
    Extract package that matches <regex>.  In case of multiple matches,
    ye will prompt for a specific package. <regex> is case insensitive
    and implicitly surrounded by '.*'.  -e disables the implicit use
    of '.*' around the given <regex>.
    If <file> is provided, ye will extract <file> only, otherwise the
    whole package content will be extracted to a directory named after
    the package filename (without extension).  <file> must match the exact
    file name in the package (usually starts with ./).
    -c is specific to .deb and .ipk packages -- ye will extract files
    from the control.tar.gz tarball in packages.

wd [-e] <regex>
workdir [-e] <regex>
    Locate the Yocto Project's workdir for <regex>.  <regex> is
    implicitly surrounded by '.*', unless -e is provided.

l [-e] [-H] <recipe pattern> <log pattern>
log [-e] [-H] <recipe pattern> <log pattern>
    Show the log files for <recipe>.  -e is only applied to
    <recipe pattern>.  <log pattern> is always implicitly surrounded
    by '.*'.  If -H ("human readable") is given on the command line,
    ye will try to make the lines that contain calls to gcc/g++ look
    more readable.

r [-e] <recipe pattern> <run script pattern>
run [-e] <recipe pattern> <run script pattern>
    Show the log files for <recipe>.  -e is only applied to
    <recipe pattern>.  <run script pattern> is always implicitly
    surrounded by '.*'.

g <args>
grep <args>
    Run 'repo grep <args>'.

sg <args>
sysroot-grep <args>
   Run 'grep -r <args> $BUILDDIR/tmp/sysroots/$MACHINE'.

bh [-d] <revisions back>
buildhistory [-d] <revisions back>
    Show changes in buildhistory <revisions back> (a positive integer).
    If -d is given, show the raw git diff output.

d [-e] <regex>
doc [-e] <regex>
    Search variable names in the reference manual that match the given
    expression <regex> and show the documentation for the selected
    match.  <regex> is case insensitive and implicitly surrounded by
    '.*'.  -e disables the implicit use of '.*' around the given
    <regex>.

x <recipe> <variable>
expand <recipe> <variable>
    Expand BitBake's variable <variable> in the context of <recipe> and
    show the final value and the recursive expansion of all variables
    and expressions involved.

cd [<dir shortcut>]
    Change to <dir shortcut>.  The following <dir shortcut> options are
    available:

    top
        Change to project's TOPDIR

    wd [<recipe>]
        Change to <recipe>'s WORKDIR or to tmp/deploy/work if
        <recipe> is not provided.

    bd
        Change to BUILDDIR

    sd
        Change to sysroot dir for MACHINE

    src [<recipe>]
        Change to <recipes>'s source dir or to the 'sources' dir
        if <recipe> is not provided

    img
        Change to tmp/deploy/MACHINE/image/

    pkg
        Change to tmp/deploy/PKG_TYPE/image/

    manifest
        Change to TOPDIR/.repo/manifests

    When called without arguments, ye cd will change to BUILDDIR.

    To use this feature, source'ing the ye-cd shell helper is required.
''' % os.path.basename(sys.argv[0]))
    if exit_code is not None:
        sys.exit(exit_code)


def main(args):
    if not args:
        usage(1)
    if '-h' in args or '-help' in args or '--help' in args:
        usage(0)
    cmd = args[0]
    cmd_args = args[1:]

    if cmd == 'cd':
        yecd = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'ye-cd')
        die('To use this feature you need to evaluate %s on the current environment (e.g., . %s).' %
            (yecd, yecd))
    elif cmd in ['bh', 'buildhistory']:
        check_builddir()
        raw_diff = False
        if '-d' in cmd_args:
            raw_diff = True
            cmd_args.remove('-d')
        if len(cmd_args) != 1:
            usage(1)
        revisions = None
        try:
            revisions = int(cmd_args[0])
        except:
            die('The argument to -d must be a positive integer.')
        if revisions < 0:
            die('The argument to -d must be a positive integer.')
        buildhistory(revisions, raw_diff)
    elif cmd == 'plumbing':
        handle_plumbing(cmd_args)
    elif cmd in ['x', 'expand']:
        if len(cmd_args) != 2:
            usage(1)
        else:
            check_builddir()
            expand_mod = __import__('bb-expand-vars')
            os.chdir(BUILDDIR)
            expand_mod.show_var_expansions(cmd_args[0], cmd_args[1])
    elif cmd in ['f', 'find', 'v', 'view', 'e', 'edit', 'sf', 'sysroot-find',
                 'wd', 'workdir', 'pf', 'pkg-find', 'pv', 'pkg-view',
                 'pi', 'pkg-info', 'px', 'pkg-extract', 'ps', 'pkg-scripts',
                 'l', 'log', 'r', 'run', 'g', 'grep', 'sg', 'sysroot-grep',
                 'd', 'doc']:
        exact = False
        raw = True
        from_control = False
        if '-e' in cmd_args:
            exact = True
            cmd_args.remove('-e')
        if '-H' in cmd_args:
            raw = False
            cmd_args.remove('-H')
        if '-c' in cmd_args:
            from_control = True
            cmd_args.remove('-c')
        if len(cmd_args) < 1:
            usage(1)
        else:
            pattern = cmd_args[0]
        if cmd_args:
            if cmd in ['g', 'grep']:
                print_matches(grep(cmd_args, [view_action, edit_action]))
            elif cmd in ['sg', 'sysroot-grep']:
                check_builddir()
                expand_mod = __import__('bb-expand-vars')
                os.chdir(BUILDDIR)
                val = expand_mod.show_var_expansions('core-image-minimal',
                                                     ['MACHINE'],
                                                     True)
                if val:
                    machine = val['MACHINE']
                else:
                    die('Could not determine MACHINE.')
                sysroot_dir = os.path.join(BUILDDIR, 'tmp', 'sysroots', machine)
                print_matches(grep(cmd_args, [view_action, edit_action], sysroot_dir))
            elif cmd in ['f', 'find', 'v', 'view', 'e', 'edit']:
                actions = None
                if cmd in ['v', 'view']:
                    actions = [view_action]
                elif cmd in ['e', 'edit']:
                    actions = [edit_action]
                else:
                    actions = [view_action, edit_action]
                print_matches(find(pattern,
                                   os.path.join(find_yocto_root(), 'sources'),
                                   exact,
                                   actions))
            elif cmd in ['sf', 'sysroot-find']:
                check_builddir()
                sysroots_dir = os.path.join(BUILDDIR, 'tmp', 'sysroots')
                if os.path.isdir(sysroots_dir):
                    print_matches(find(pattern,
                                       sysroots_dir,
                                       exact,
                                       [view_action, edit_action]))
            elif cmd in ['wd', 'workdir']:
                check_builddir()
                if os.path.isdir(os.path.join(BUILDDIR, 'tmp', 'work')):
                    show_workdir(pattern, exact)
            elif cmd in ['d', 'doc']:
                doc(pattern, exact)
            elif cmd in ['pf', 'pkg-find', 'pv', 'pkg-view', 'pi', 'pkg-info',
                         'px', 'pkg-extract', 'ps', 'pkg-scripts']:
                check_builddir()
                deploy_dir = os.path.join(BUILDDIR, 'tmp', 'deploy')
                pkg_dirs = [ os.path.join(deploy_dir, fmt) for fmt in ['deb', 'ipk', 'rpm'] ]
                pkg_dirs = [ d for d in pkg_dirs if os.path.isdir(d) ]
                pkg_dir = None
                file_to_extract = ''
                if not pkg_dirs:
                    sys.exit(0)
                if len(pkg_dirs) > 1:
                    fmts = [ os.path.basename(dir) for dir in pkg_dirs ]
                    choice = prompt_action([ (fmt[0], fmt) for fmt in fmts ])
                    pkg_dir = pkg_dirs[choice]
                else:
                    pkg_dir = pkg_dirs[0]
                actions = None
                if cmd in ['pv', 'pkg-view']:
                    actions = [pkg_view_action]
                elif cmd in ['pi', 'pkg-info']:
                    actions = [pkg_info_action]
                elif cmd in ['ps', 'pkg-scripts']:
                    actions = [pkg_scripts_action]
                elif cmd in ['px', 'pkg-extract']:
                    if len(cmd_args) > 1:
                        file_to_extract = cmd_args[1]
                    actions = [pkg_extract_action(file_to_extract, from_control)]
                else:
                    actions = [pkg_view_action,
                               pkg_info_action,
                               pkg_scripts_action,
                               pkg_extract_action(file_to_extract, from_control)]
                print_matches(find(pattern, pkg_dir, exact, actions))
            elif cmd in ['l', 'log', 'r', 'run']:
                log_pattern = '.*'
                if len(cmd_args) > 1:
                    log_pattern = cmd_args[1]
                if cmd in ['l', 'log']:
                    list_logs(pattern, log_pattern, exact, raw)
                else:
                    list_run_scripts(pattern, log_pattern, exact)
        else: usage(1)
    else:
        usage(1)


main(sys.argv[1:])
