#! /usr/bin/env python

## ye: Yocto Explorer
##
## Copyright (C) 2014 O.S. Systems Software LTDA
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU Affero General Public License as
## published by the Free Software Foundation, either version 3 of the
## License, or (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU Affero General Public License for more details.
##
## You should have received a copy of the GNU Affero General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

### TODO
# Implement exclusion pattern for grep (option should not clash with git grep's)

from __future__ import print_function

import os
import re
import sys
import glob
import subprocess

def die(msg):
    sys.stderr.write(msg + '\n')
    sys.exit(1)

def is_program_available(program):
    progpaths = os.environ['PATH'].split(':')
    for dir in progpaths:
        progpath = os.path.join(dir, program)
        if os.path.isfile(progpath) and os.access(progpath, os.X_OK):
            return True
    return False

EDITOR_ALTERNATIVES = [('emacs', '-nw'), 'mg', 'zile', 'qemacs', 'nano', 'vim', 'vi']

def find_editor():
    for option in EDITOR_ALTERNATIVES:
        editor = None
        args = None
        if isinstance(option, tuple):
            editor = option[0]
            args = option[1]
        else:
            editor = option
        if is_program_available(editor):
            return '%s %s' % (editor, args)
    die('Could not find an editor.  Please, set the YE_EDITOR environment variable.')

YE_PAGER = None
if 'YE_PAGER' in os.environ:
    YE_PAGER = os.environ['YE_PAGER']
elif 'PAGER' in os.environ:
    YE_PAGER = os.environ['PAGER'] + ' %s'
else:
    YE_PAGER = 'nl -ba "%s" | less'

YE_EDITOR = None
if 'YE_EDITOR' in os.environ:
    YE_EDITOR = os.environ['YE_EDITOR']
elif 'EDITOR' in os.environ:
    YE_EDITOR = os.environ['EDITOR']
else:
    YE_EDITOR = find_editor()
YE_EDITOR += ' "%s"'

BUILDDIR = None
try:
    BUILDDIR = os.environ['BUILDDIR']
except:
    pass

HOME = os.environ['HOME']


def colorize(text, pattern):
    if sys.stdout.isatty():
        return re.sub(pattern,
                      lambda m: '\x1b[31;1m{}\x1b[0m'.format(m.group()), text)
    else:
        return text


def find_yocto_root():
    def inner_find(dir):
        repo_dir = os.path.join(dir, '.repo')
        if os.path.exists(repo_dir) and os.path.isdir(repo_dir):
            return dir
        elif dir == '/':
            return False
        else:
            return inner_find(os.path.dirname(dir))
    yocto_root = inner_find(os.getcwd())
    return yocto_root or die("ERROR: won't search from /.")


def find_files(basedir, maxdepth=None, pattern='.*'):
    depth = 0
    re_pattern = re.compile(pattern)
    re_skip_pattern = re.compile('.*~$|^\.#|^#.*#$|.*\.pyc$')
    results = []
    match_whole_path = '/' in pattern
    for root, dirs, files in os.walk(basedir):
        dirs[:] = [d for d in dirs if not d[0] == '.']
        depth += 1
        if maxdepth and depth > maxdepth:
            return results
        all_files = None
        if match_whole_path:
            all_files = [ os.path.join(root, f) for f in dirs + files ]
        else:
            all_files = dirs + files
        for file in all_files:
            if not re_skip_pattern.match(file) and re_pattern.match(file):
                results.append(os.path.join(root, file))
    return results


def parse_choice(choice, valid_shortcuts):
    result = None
    try:
        choice_num = int(choice)
        result = (choice_num, None)
    except:
        pass
    if result:
        return result
    shortcut = choice[-1:]
    choice = choice[:-1]
    result = (None, None)
    try:
        choice_num = int(choice)
        if not shortcut or shortcut in valid_shortcuts:
            result = (choice_num, shortcut)
    except:
        pass
    return result


def prompt_file(options, option_formatter=lambda x: x, valid_shortcuts=[]):
    maxopts = len(options) - 1

    def inner_prompt():
        for i, text in enumerate(options):
            print('[%d] %s [%d]' % (i, option_formatter(text), i))
        print('Option (ENTER to cancel): ', end='')
        return raw_input()

    while True:
        choice = inner_prompt()
        if choice == '': # user cancelled
            sys.exit(0)
        choice, shortcut = parse_choice(choice, valid_shortcuts)
        if choice is not None and choice <= maxopts:
            return (choice, shortcut)

def prompt_action(options):
    def inner_prompt():
        for short, text in options:
            print('[%s] %s' % (short, text))
        print('Option (ENTER to cancel): ', end='')
        return raw_input()

    short_options = [ o[0] for o in options ]
    while True:
        choice = inner_prompt()
        if choice == '': # user cancelled
            sys.exit(0)
        try:
            index = short_options.index(choice)
            return index
        except:
            pass

def shorten_path(path):
    home_pos = path.find(HOME)
    if home_pos == 0:
        homeless_path = path[len(HOME):]
        if homeless_path.startswith('/'):
            return '~' + homeless_path
        else:
            return '~/' + homeless_path
    else:
        return path

def find(pattern, basedir, exact, actions):
    ''' actions = [('label', 'shortcut', proc) ...] '''
    results = []
    shortcut = None
    orig_pattern = pattern
    if not exact:
        pattern = '.*%s.*' % pattern
    for file in find_files(basedir, pattern=pattern):
        if not os.path.isdir(file):
            results.append(file)
    if sys.stdout.isatty():
        if results:
            valid_shortcuts = [ a[1] for a in actions ]
            if len(results) > 1:
                choice, shortcut = prompt_file(results,
                                               lambda file: colorize(shorten_path(file),
                                                                     orig_pattern),
                                               valid_shortcuts)
                file = results[choice]
            else:
                file = results[0]
                print(colorize(shorten_path(file), orig_pattern))
            if len(actions) == 1:
                actions[0][2](file)
                return file
            if shortcut:
                for action in actions:
                    if action[1] == shortcut:
                        action[2](file)
            else:
                action = prompt_action([ (a[1], a[0]) for a in actions ])
                actions[action][2](file)
            return file
    else:
        return results


def check_builddir():
    if not BUILDDIR:
        die("ERROR: Could not determine the Yocto Project's build directory.")


def find_workdir(pattern, exact):
    check_builddir()
    results = []
    orig_pattern = pattern
    if not exact:
        pattern = '.*%s.*' % pattern
    re_pattern = re.compile(pattern)
    paths = glob.glob(os.path.join(BUILDDIR, 'tmp', 'work', '*', '*'))
    for path in paths:
        if os.path.isdir(path):
            basedir = os.path.dirname(path)
            dir = os.path.basename(path)
            if re_pattern.match(dir):
                results.append(os.path.join(basedir, dir))
    return results


def show_workdir(pattern, exact):
    for result in find_workdir(pattern, exact):
        print(colorize(result, pattern))


def print_matches(matches):
    if matches:
        if matches.__class__.__name__ == 'list':
            for match in matches:
                print(match)
        else:
            # a string
            print(matches)


def pkg_view(file):
    ext = os.path.splitext(file)[1]
    if ext in ['.ipk', '.deb']:
        os.system("ar p %s data.tar.gz | tar tvzf -" % file)
    elif ext == '.rpm':
        os.system("rpm -qlp %s" % file)
    else:
        die("ERROR: unsupported package file extension: %s" % ext)


def pkg_info(file):
    ext = os.path.splitext(file)[1]
    if ext in ['.ipk', '.deb']:
        os.system("ar p %s control.tar.gz | tar xzf - ./control -O" % file)
    elif ext == '.rpm':
        os.system("rpm -qip %s" % file)
    else:
        die("ERROR: unsupported package file extension: %s" % ext)


view_action = ('View', 'v', lambda file: os.system(YE_PAGER % file))

edit_action = ('Edit', 'e', lambda file: os.system(YE_EDITOR % file))

pkg_view_action = ('View', 'v', pkg_view)

pkg_info_action = ('Info', 'i', pkg_info)


def list_temp_files(file_type, recipe_pattern, log_pattern, exact):
    wds = find_workdir(recipe_pattern, exact)
    if not wds:
        sys.exit(1)
    if len(wds) > 1:
        choice, _ = prompt_file(wds, os.path.basename)
        wd = wds[choice]
    else:
        wd = wds[0]
    if not os.path.isdir(wd):
        sys.exit(1)
    if file_type == 'log':
        print('=== Showing logs for %s' % os.path.basename(wd))
    else:
        print('=== Showing run scripts for %s' % os.path.basename(wd))
    version_dirs = glob.glob(os.path.join(wd, '*'))
    if len(version_dirs) > 1:
        choice, _ = prompt_file(version_dirs, os.path.basename)
        version_dir = version_dirs[choice]
    else:
        version_dir = version_dirs[0]
    log_dir = os.path.join(version_dir, 'temp')
    logs = filter(os.path.islink,
                  find_files(log_dir,
                             pattern='%s\..*%s.*' % (file_type, log_pattern)))
    log = None
    if logs:
        if len(logs) > 1:
            choice, _ = prompt_file(logs, os.path.basename)
            log = logs[choice]
        else:
            log = logs[0]
        print('=== %s' % log)
        view_action[2](log)
        print(log_dir)


def list_logs(recipe_pattern, log_pattern, exact):
    list_temp_files('log', recipe_pattern, log_pattern, exact)


def list_run_scripts(recipe_pattern, log_pattern, exact):
    list_temp_files('run', recipe_pattern, log_pattern, exact)


def grep(args, actions):
    p = subprocess.Popen(['repo', 'grep'] + args, stdout=subprocess.PIPE)
    regex_pattern = filter(lambda opt: not opt.startswith('-'), args)
    if not regex_pattern:
        die('Could not determine the pattern for grep.')
    if len(regex_pattern) > 1:
        die('Multiple patterns for grep is not supported.')
    regex_pattern = regex_pattern[0]
    output = p.communicate()[0]
    results = output.split('\n')[:-1] # the last line is always empty
    if sys.stdout.isatty():
        if len(results) == 0:
            return None
        elif len(results) > 1:
            choice, shortcut = prompt_file(results,
                                           option_formatter=lambda o: colorize(o, regex_pattern),
                                           valid_shortcuts=['v', 'e'])
            match = results[choice]
        else:
            match = results[0]
        file = match.split(':')[0] # let's hope filenames don't contain ':'
        return find(file,
                    os.path.join(find_yocto_root(), 'sources'),
                    False,
                    [view_action, edit_action])
    else:
        return results

def buildhistory(revisions, raw_diff):
    bhdir = os.path.join(BUILDDIR, 'buildhistory')
    if not os.path.isdir(bhdir):
        die('Could not find the buildhistory directory at %s.' % bhdir)
    rev_window = 'HEAD~%d..HEAD' % revisions
    if raw_diff:
        os.system('cd %s && git diff %s' % (bhdir, rev_window))
    else:
        os.system('buildhistory-diff -p %s %s' % (bhdir, rev_window))


def usage(exit_code=None, cmd=None):
    printer = None
    if exit_code is not None and exit_code != 0:
        printer = sys.stderr.write
    else:
        printer = sys.stdout.write
    printer('''Usage: %s <command> [ <options> ]

f [-e] <regex>
find [-e] <regex>
    Locate paths (in the "sources" directory) that match the given
    expression <regex>.  <regex> is case insensitive and implicitly
    surrounded by '.*'.  -e disables the implicit use of '.*' around
    the given <regex>.  Note that, unless <regex> contains /, matching
    is attempted on filenames only (not on dirnames).  If <regex>
    contains /, matching is attempted on the full path.

v [-e] <regex>
view [-e] <regex>
    Shortcut to find & view.  If multiple files are found, a prompt for
    files will be displayed (but not for actions).

e [-e] <regex>
edit [-e] <regex>
    Shortcut to find & edit.  If multiple files are found, a prompt for
    files will be displayed (but not for actions).

sf [-e] <regex>
sysroot-find [-e] <regex>
    Locate paths (in the "sysroots" directory) that match the given
    expression <regex>.  <regex> is case insensitive and implicitly
    surrounded by '.*'.  -e disables the implicit use of '.*' around
    the given <regex>.  Note that, unless <regex> contains /, matching
    is attempted on filenames only (not on dirnames).  If <regex>
    contains /, matching is attempted on the full path.

pf [-e] <regex>
pkg-find [-e] <regex>
    Like 'find', but for packages.

wd [-e] <regex>
workdir [-e] <regex>
    Locate the Yocto Project's workdir for <regex>.  <regex> is
    implicitly surrounded by '.*', unless -e is provided.

l [-e] <recipe pattern> <log pattern>
log [-e] <recipe pattern> <log pattern>
    Show the log files for <recipe>.  -e is only applied to
    <recipe pattern>.  <log pattern> is always implicitly surrounded
    by '.*'.

r [-e] <recipe pattern> <run script pattern>
run [-e] <recipe pattern> <run script pattern>
    Show the log files for <recipe>.  -e is only applied to
    <recipe pattern>.  <run script pattern> is always implicitly
    surrounded by '.*'.

g <args>
grep <args>
    Run 'repo grep <args>'.

bh [-d] <revisions back>
buildhistory [-d] <revisions back>
    Show changes in buildhistory <revisions back> (a positive integer).
    If -d is given, show the raw git diff output.
''' % os.path.basename(sys.argv[0]))
    if exit_code is not None:
        sys.exit(exit_code)


def main(args):
    if not args:
        usage(1)
    if '-h' in args or '-help' in args or '--help' in args:
        usage(0)
    cmd = args[0]
    cmd_args = args[1:]

    if cmd in ['bh', 'buildhistory']:
        check_builddir()
        raw_diff = False
        if '-d' in cmd_args:
            raw_diff = True
            cmd_args.remove('-d')
        if len(cmd_args) != 1:
            usage(1)
        revisions = None
        try:
            revisions = int(cmd_args[0])
        except:
            die('The argument to -d must be a positive integer.')
        if revisions < 0:
            die('The argument to -d must be a positive integer.')
        buildhistory(revisions, raw_diff)
    elif cmd in ['f', 'find', 'v', 'view', 'e', 'edit', 'sf', 'sysroot-find',
                 'wd', 'workdir', 'pf', 'pkg-find', 'l', 'log', 'r', 'run',
                 'g', 'grep']:
        exact = False
        if '-e' in cmd_args:
            exact = True
            cmd_args.remove('-e')
        if len(cmd_args) < 1:
            usage(1)
        else:
            pattern = cmd_args[0]
        if cmd_args:
            if cmd in ['g', 'grep']:
                print_matches(grep(cmd_args, [view_action, edit_action]))
            elif cmd in ['f', 'find', 'v', 'view', 'e', 'edit']:
                actions = None
                if cmd in ['v', 'view']:
                    actions = [view_action]
                elif cmd in ['e', 'edit']:
                    actions = [edit_action]
                else:
                    actions = [view_action, edit_action]
                print_matches(find(pattern,
                                   os.path.join(find_yocto_root(), 'sources'),
                                   exact,
                                   actions))
            elif cmd in ['sf', 'sysroot-find']:
                check_builddir()
                sysroots_dir = os.path.join(BUILDDIR, 'tmp', 'sysroots')
                if os.path.isdir(sysroots_dir):
                    print_matches(find(pattern,
                                       sysroots_dir,
                                       exact,
                                       [view_action, edit_action]))
            elif cmd in ['wd', 'workdir']:
                check_builddir()
                if os.path.isdir(os.path.join(BUILDDIR, 'tmp', 'work')):
                    show_workdir(pattern, exact)
            elif cmd in ['pf', 'pkg-find']:
                check_builddir()
                deploy_dir = os.path.join(BUILDDIR, 'tmp', 'deploy')
                pkg_dirs = [ os.path.join(deploy_dir, fmt) for fmt in ['deb', 'ipk', 'rpm'] ]
                pkg_dirs = filter(os.path.isdir, pkg_dirs)
                pkg_dir = None
                if not pkg_dirs:
                    sys.exit(0)
                if len(pkg_dirs) > 1:
                    fmts = [ os.path.basename(dir) for dir in pkg_dirs ]
                    choice = prompt_action( [ (fmt[0], fmt) for fmt in fmts ])
                    pkg_dir = pkg_dirs[choice]
                else:
                    pkg_dir = pkg_dirs[0]
                print_matches(find(pattern,
                                   pkg_dir,
                                   exact,
                                   [pkg_view_action, pkg_info_action]))
            elif cmd in ['l', 'log', 'r', 'run']:
                log_pattern = '.*'
                if len(cmd_args) > 1:
                    log_pattern = cmd_args[1]
                if cmd in ['l', 'log']:
                    list_logs(pattern, log_pattern, exact)
                else:
                    list_run_scripts(pattern, log_pattern, exact)
        else: usage(1)
    else:
        usage(1)


main(sys.argv[1:])
